# Written by Roy Tseng
#
# Based on:
# --------------------------------------------------------
# Copyright (c) 2017-present, Facebook, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################


from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import cv2
import numpy as np
import os
import pycocotools.mask as mask_util

from utils.colormap import colormap
import utils.keypoints as keypoint_utils

# Use a non-interactive backend
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
from subprocess import call

import logging

plt.rcParams['pdf.fonttype'] = 42  # For editing in Adobe Illustrator

_GRAY = (218, 227, 218)
_GREEN = (18, 127, 15)
_WHITE = (255, 255, 255)

# -----------------------------------------------------------------------------------
def render_scene2(render_parameters, render_img_name="test.png", render_dir="render_test"):
    num_objects = render_parameters.shape[0]
    render_string = []
    for i in range(num_objects):
        object_string = ';'.join(map(str, render_parameters[i]))
        render_string.append(object_string)

#     pdb.set_trace()
    render_string = '#'.join(render_string)
    call(('python2', 'lib/render/test_unreal_scene2.py',
        '--port', str(9000),
        '--render_parameters', render_string, 
        '--render_dir', render_dir,
        '--render_img_name', render_img_name))

    render_img_path = os.path.join(render_dir, render_img_name[:-4])
    view1_img = cv2.imread(render_img_path + "_view1.png")
    view2_img = cv2.imread(render_img_path + "_view2.png")
    view3_img = cv2.imread(render_img_path + "_view3.png")

    return view1_img, view2_img, view3_img
# -----------------------------------------------------------------------------------
def find_x_y_3d(x_2d, y_2d, lookup_table):
    min_dist = 100000
    x_3d = 1000; y_3d = 1000
    
    for key, value in lookup_table.items():
        (val_x_2d, val_y_2d) = value
        dist = abs(val_x_2d - x_2d) + abs(val_y_2d - y_2d)
        if(dist < min_dist):
            min_dist = dist
            (x_3d, y_3d) = key
    
    x_3d -= 0.15
    y_3d -= 0.05
    
    x_3d = round(x_3d, 2)
    y_3d = round(y_3d, 2)
    return x_3d, y_3d
# ----------------------------------------------------------


def convert_from_cls_format(cls_boxes, cls_segms, cls_attributes, cls_keyps):
    """Convert from the class boxes/segms/keyps format generated by the testing
    code.
    """
    box_list = [b for b in cls_boxes if len(b) > 0]
    if len(box_list) > 0:
        boxes = np.concatenate(box_list)
    else:
        boxes = None
    if cls_segms is not None:
        segms = [s for slist in cls_segms for s in slist]
    else:
        segms = None
    if cls_keyps is not None:
        keyps = [k for klist in cls_keyps for k in klist]
    else:
        keyps = None
    if cls_attributes is not None:
        attributes = [a for alist in cls_attributes for a in alist]
    else:
        attributes = None
    classes = []
    for j in range(len(cls_boxes)):
        classes += [j] * len(cls_boxes[j])
    return boxes, segms, keyps, attributes, classes


def vis_bbox_opencv(img, bbox, thick=1):
    """Visualizes a bounding box."""
    (x0, y0, w, h) = bbox
    x1, y1 = int(x0 + w), int(y0 + h)
    x0, y0 = int(x0), int(y0)
    cv2.rectangle(img, (x0, y0), (x1, y1), _GREEN, thickness=thick)
    return img


def get_class_string(class_index, score, dataset):
    class_text = dataset.classes[class_index] if dataset is not None else \
        'id{:d}'.format(class_index)
    return class_text + ' {:0.2f}'.format(score).lstrip('0')


def vis_one_image(
        im, im_name, output_dir, boxes, segms=None, keypoints=None, thresh=0.9,
        kp_thresh=2, dpi=200, box_alpha=0.0, dataset=None, show_class=False,
        ext='pdf', depth_map=None, normal_map=None, attributes=None):
    """Visual debugging of detections."""

    rgb_output_dir = os.path.join(output_dir, 'rgb')
    depth_output_dir = os.path.join(output_dir, 'depth')
    normal_output_dir = os.path.join(output_dir, 'normal')
    render_output_dir = os.path.join(output_dir, 'render')
    dir_list = [rgb_output_dir,
                depth_output_dir,
                normal_output_dir,
                os.path.join(render_output_dir, 'target'),
                os.path.join(render_output_dir, 'view1'),
                os.path.join(render_output_dir, 'view2'),
                os.path.join(render_output_dir, 'view3')
                ]

    for dir_name in dir_list:
        if(not os.path.exists(dir_name)):
            os.makedirs(dir_name)

    if isinstance(boxes, list):
        boxes, segms, keypoints, attributes, classes = convert_from_cls_format(
            boxes, segms, attributes, keypoints)

    if boxes is None or boxes.shape[0] == 0 or max(boxes[:, 4]) < thresh:
        return

    if segms is not None:
        masks = mask_util.decode(segms)

    color_list = colormap(rgb=True) / 255

    fig = plt.figure(frameon=False)
    fig.set_size_inches(2*im.shape[1] / dpi, 2*im.shape[0] / dpi)
    ax = plt.Axes(fig, [0., 0., 0.5, 1])
    ax.axis('off')
    fig.add_axes(ax)
    ax.imshow(im)

    # Display in largest to smallest order to reduce occlusion
    areas = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])
    sorted_inds = np.argsort(-areas)

    mask_color_id = 0
    render_parameters = []
    for i in sorted_inds:
        bbox = boxes[i, :4]
        score = boxes[i, -1]

        area = (bbox[2] - bbox[0])*(bbox[3] - bbox[1])
        if area < 5000:
            continue

        if score < thresh:
            continue

        class_label = classes[i] - 1 #remove the background
        color_label = attributes[i][0]; color = dataset.color_classes[attributes[i][0]]
        rotation = dataset.rotation_classes[attributes[i][1]]
        center_x = ((bbox[0] + bbox[2])/2.0)
        center_y = ((bbox[1] + bbox[3])/2.0)
        center_x = center_x/im.shape[1] #normalize in 0 to 1
        center_y = center_y/im.shape[0] #normalize in 0 to 1

        x, y = find_x_y_3d(center_x, center_y, dataset.lookup_table)

        object_render_parameters = [class_label, color_label, x, y, rotation]
        render_parameters.append(np.asarray(object_render_parameters))
        
        print(dataset.classes[classes[i]], score, '{} x:{} y:{} rotation:{}'.format(color, x, y, rotation))
        # show box (off by default, box_alpha=0.0)
        ax.add_patch(
            plt.Rectangle((bbox[0], bbox[1]),
                          bbox[2] - bbox[0],
                          bbox[3] - bbox[1],
                          fill=False, edgecolor='g',
                          linewidth=0.5, alpha=box_alpha))

        if show_class:
            ax.text(
                bbox[0], bbox[1] - 2,
                get_class_string(classes[i], score, dataset) + '{} x:{} y:{} rot:{}'.format(color, x, y, rotation),
                fontsize=3,
                family='serif',
                bbox=dict(
                    facecolor='g', alpha=0.4, pad=0, edgecolor='none'),
                color='white')

        # show mask
        if segms is not None and len(segms) > i:
            img = np.ones(im.shape)
            color_mask = color_list[mask_color_id % len(color_list), 0:3]
            mask_color_id += 1

            w_ratio = .4
            for c in range(3):
                color_mask[c] = color_mask[c] * (1 - w_ratio) + w_ratio
            for c in range(3):
                img[:, :, c] = color_mask[c]
            e = masks[:, :, i]

            _, contour, hier = cv2.findContours(
                e.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)

            for c in contour:
                polygon = Polygon(
                    c.reshape((-1, 2)),
                    fill=True, facecolor=color_mask,
                    edgecolor='w', linewidth=1.2,
                    alpha=0.5)
                ax.add_patch(polygon)

    #------------------------for loop ends----------------------------------------
    #write the rendering results
    num_objects = len(render_parameters)
    if(num_objects > 0):
        view1_img, view2_img, view3_img = render_scene2(np.asarray(render_parameters), render_dir=render_output_dir)
        height, width, channels = view1_img.shape
        im2show = cv2.resize(im, (width, height))
        im2show = cv2.cvtColor(im2show, cv2.COLOR_BGR2RGB)

        result_path = os.path.join(render_output_dir, 'target', im_name + "_det.jpg")
        cv2.imwrite(result_path, im2show)

        result_path = os.path.join(render_output_dir, 'view1', im_name + "_v1.jpg")
        cv2.imwrite(result_path, view1_img)

        result_path = os.path.join(render_output_dir, 'view2', im_name + "_v2.jpg")
        cv2.imwrite(result_path, view2_img)

        result_path = os.path.join(render_output_dir, 'view3', im_name + "_v3.jpg")
        cv2.imwrite(result_path, view3_img)

        ax = plt.Axes(fig, [0.5, 0, 0.5, 1])
        ax.axis('off')
        fig.add_axes(ax)
        ax.imshow(cv2.cvtColor(view1_img, cv2.COLOR_BGR2RGB))

    # --------------------------------------------------------------------------
    output_name = os.path.basename(im_name) + '.' + ext
    fig.savefig(os.path.join(rgb_output_dir, '{}'.format(output_name)), dpi=dpi)
    plt.close('all')

    if depth_map is not None:
        fig = plt.figure(frameon=False)
        fig.set_size_inches(2*depth_map.shape[1] / dpi, 2*depth_map.shape[0] / dpi)
        ax = plt.Axes(fig, [0., 0., 0.5, 1])
        ax.axis('off')
        fig.add_axes(ax)
        ax.imshow(im)
        ax = plt.Axes(fig, [0.5, 0, 0.5, 1])
        ax.axis('off')
        fig.add_axes(ax)
        ax.imshow(depth_map, cmap='gray')

        output_name = os.path.basename(im_name) + '.' + ext
        fig.savefig(os.path.join(depth_output_dir, '{}'.format(output_name)), dpi=dpi)
        plt.close('all')

    if normal_map is not None:
        fig = plt.figure(frameon=False)
        fig.set_size_inches(2*normal_map.shape[1] / dpi, 2*normal_map.shape[0] / dpi)
        ax = plt.Axes(fig, [0., 0., 0.5, 1])
        ax.axis('off')
        fig.add_axes(ax)
        ax.imshow(im)
        ax = plt.Axes(fig, [0.5, 0, 0.5, 1])
        ax.axis('off')
        fig.add_axes(ax)
        ax.imshow(normal_map)

        output_name = os.path.basename(im_name) + '.' + ext
        fig.savefig(os.path.join(normal_output_dir, '{}'.format(output_name)), dpi=dpi)
        plt.close('all')

    return